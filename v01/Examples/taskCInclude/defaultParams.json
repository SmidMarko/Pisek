{"defaultFilterTests-python3": "@defaultFilterTests-python", "defaultFilterTests-python2": "@defaultFilterTests-python", "defaultEvaluationGenerations": ["@defaultGeneration"], "defaultGeneration": null, "defaultFilterTests-c": "@defaultFilterTests", "defaultFilterTests-sh": "@defaultFilterTests", "solutionDependencies": [], "defaultDependencies-ml": "@defaultDependencies-ocaml", "rootPath": "/home/michel/franceioi/tasks/v01/", "defaultDependencies-cpp": "@defaultDependencies-c", "defaultFilterTests-javascool": "@defaultFilterTests", "defaultGenerator": null, "defaultSanitizer": {"runExecution": "@defaultToolExecParams", "compilationDescr": {"files": [{"content": "#!/bin/sh\necho \"Dummy script\"\nexit 0\n", "name": "true.sh"}], "dependencies": [], "language": "sh"}, "compilationExecution": "@defaultToolCompParams"}, "solutionPath": "", "defaultDependencies-sh": [], "solutionId": "solution", "defaultDependencies-javascool": [], "defaultSolutionCompParams": {"memoryLimitKb": 64000, "stderrTruncateKb": -1, "getFiles": [], "useCache": true, "timeLimitMs": 5000, "stdoutTruncateKb": -1}, "genJsonVersion": "f91bb4d5bc2be15c1a4201f0be55a3f0e0b1162e", "defaultEvaluationExtraTests": "@defaultExtraTests", "defaultToolExecParams": "@defaultToolCompParams", "defaultDependencies-python": [], "defaultFilterTests-python": "@defaultFilterTests", "defaultDependencies-java": [{"path": "$ROOT_PATH/_common/lib/java/algorea/Scanner.java", "name": "algorea/Scanner.java"}], "solutionFilterTests": "@defaultFilterTests", "defaultDependencies-py": "@defaultDependencies-python", "defaultExtraTests": [{"path": "$TASK_PATH/tests/files/test01.in", "name": "test01.in"}, {"path": "$TASK_PATH/tests/files/test01.out", "name": "test01.out"}], "defaultFilterTests-shell": "@defaultFilterTests", "defaultDependencies-c": [], "defaultSolutionExecParams": {"memoryLimitKb": 64000, "stderrTruncateKb": -1, "getFiles": [], "useCache": true, "timeLimitMs": 5000, "stdoutTruncateKb": -1}, "defaultFilterTests-ocaml": "@defaultFilterTests", "defaultDependencies-pas": "@defaultDependencies-pascal", "defaultDependencies-pascal": [], "defaultDependencies-python2": "@defaultDependencies-python", "defaultDependencies-python3": "@defaultDependencies-python", "defaultEvaluationChecker": "@defaultChecker", "defaultEvaluationExecutions": [{"idSolution": "@solutionId", "filterTests": "@solutionFilterTests", "runExecution": "@defaultSolutionExecParams", "noFeedbackTests": "@defaultNoFeedbackTests", "id": "@solutionExecId"}], "defaultEvaluationSanitizer": "@defaultSanitizer", "defaultDependencies-ocaml": [], "defaultFilterTests-pascal": "@defaultFilterTests", "defaultFilterTests-ml": "@defaultFilterTests-ocaml", "defaultFilterTests-java": "@defaultFilterTests", "defaultNoFeedbackTests": ["*.nofeedback.in"], "defaultFilterTests-py": "@defaultFilterTests-python", "defaultFilterTests": ["*.in"], "defaultToolCompParams": {"memoryLimitKb": 131072, "stderrTruncateKb": -1, "getFiles": [], "useCache": true, "timeLimitMs": 60000, "stdoutTruncateKb": -1}, "defaultEvaluationGenerators": ["@defaultGenerator"], "defaultChecker": {"runExecution": "@defaultToolExecParams", "compilationDescr": {"files": [{"content": "#!/usr/bin/env python2.7\n# -*- coding: utf-8 -*-\n\n# Default checking program: checks the output of the solution is the given\n# expected output (test.out).\n# Note that it can be used as a library, via the diff function.\n# Takes three arguments on command-line:\n#   ./defaultChecker.py test.solout test.in test.out\n# where\n#   test.solout is the solution output\n#   test.in is the test input given to the solution (not used)\n#   test.out is the expected output (if given by the task, else an empty file)\n\nfrom json import dumps\nfrom subprocess import Popen, PIPE\nfrom sys import argv, exit\n\nDEFAULT_OPTIONS = {\n    'ignoreSpaceChange': True,\n    'ignoreBlankLines': True,\n    'maxChars': 500\n    }\n\n\ndef utf8safe(s):\n    \"\"\"Remove characters invalid in UTF-8.\"\"\"\n    return s.decode('utf-8', errors='replace').encode('utf-8')\n\n\ndef readRealLine(handle, options):\n    l = \"\\n\"\n    if options['ignoreBlankLines']:\n        if options['ignoreSpaceChange']:\n            while l != '' and l.strip() == '':\n                l = handle.readline()\n        else:\n            while l != '' and len(l) == 1:\n                l = handle.readline()\n    else:\n        l = handle.readline()\n    return l\n\n\ndef diff(solPath, outPath, options=None):\n    \"\"\"Generate a diff report of two files.\n    The arguments are:\n    -solPath: path to the solution output\n    -outPath: path to the expected output\n    -options: dict with the following options:\n     ignoreSpaceChange (bool): ignore consecutive whitespaces\n     ignoreBlankLines (bool): ignore blank lines\n     maxChar (int): maximum chars in the displayed output\n    Returns a tuple (grade, result), where grade is the grade from 0 to 100,\n    and result is a dict containing the diff information.\"\"\"\n\n    # Read options\n    if options:\n        opt = {}\n        opt.update(DEFAULT_OPTIONS)\n        opt.update(options)\n    else:\n        opt = DEFAULT_OPTIONS\n\n    # Prepare diff\n    # Options:\n    # -u for unified (expected display)\n    # -a to always treat as text (avoid special messages when the output\n    # doesn't resemble text)\n    diffOptions = '-ua'\n    if opt['ignoreSpaceChange']: diffOptions += 'b'\n    if opt['ignoreBlankLines']:\n        diffOptions += 'B'\n        # diff -B has an error, and doesn't compare the very last character of\n        # the last line if it's not a newline\n        # We add a space and a newline at the end of both files as a workaround\n        open(solPath, 'a').write(' \\n')\n        open(outPath, 'a').write(' \\n')\n\n    # Execute diff\n    diffProc = Popen(['/usr/bin/env', 'diff', diffOptions,\n        solPath, outPath], stdout=PIPE)\n\n    # Ignore first two lines\n    do = diffProc.stdout\n    do.readline()\n    o = do.readline()\n\n    # We cannot rely on returncode as diff can have closed its output without\n    # being finished yet\n    if not o:\n        # The files are identical\n        return (100, {})\n\n    # The files aren't identical, analyze diff output\n\n    # Import only because we need them\n    from collections import OrderedDict\n    from os.path import getsize\n    from string import whitespace\n\n    result = OrderedDict()\n\n    # The chunk line is always the same for the two files, but if one file is\n    # empty, diff will give a line number of 0\n    chunkLine = max(int(do.readline().split()[2].split(',')[0]), 1)\n\n    # Start reading the actual files\n    # stderr=PIPE is generally not good, but tail will never fill it\n    solReadProc = Popen(['/usr/bin/env', 'tail', '-q', '-n', '+%d' % chunkLine,\n        solPath], stdout=PIPE, stderr=PIPE)\n    solRead = solReadProc.stdout\n    expReadProc = Popen(['/usr/bin/env', 'tail', '-q', '-n', '+%d' % chunkLine,\n        outPath], stdout=PIPE, stderr=PIPE)\n    expRead = expReadProc.stdout\n\n    solLines = []\n    expLines = []\n\n    truncatedAfter = False\n\n    # Read diff output\n    curLine = chunkLine\n    diffLine = None\n    lastLine = do.readline()\n    # Read maximum 3 lines after the diff line\n    # (these variables are still incremented past 3 but the lines aren't\n    # actually added)\n    solPostDiff = 0\n    expPostDiff = 0\n    while lastLine:\n        if lastLine[0] == ' ':\n            if solPostDiff < 3:\n                solLines.append(readRealLine(solRead, opt))\n            else:\n                truncatedAfter = True\n            if expPostDiff < 3:\n                expLines.append(readRealLine(expRead, opt))\n            else:\n                truncatedAfter = True\n            if diffLine is not None:\n                solPostDiff += 1\n                expPostDiff += 1\n        elif lastLine[0] == '-':\n            if opt['ignoreBlankLines'] and lastLine[1:].strip() == '':\n                lastLine = do.readline()\n                continue\n            if solPostDiff < 3:\n                solLines.append(readRealLine(solRead, opt))\n            else:\n                truncatedAfter = True\n            if diffLine is None:\n                diffLine = curLine\n            if diffLine is not None:\n                solPostDiff += 1\n        elif lastLine[0] == '+':\n            if opt['ignoreBlankLines'] and lastLine[1:].strip() == '':\n                lastLine = do.readline()\n                continue\n            if expPostDiff < 3:\n                expLines.append(readRealLine(expRead, opt))\n            else:\n                truncatedAfter = True\n            if diffLine is None:\n                diffLine = curLine\n            if diffLine is not None:\n                expPostDiff += 1\n\n        curLine += 1\n        lastLine = do.readline()\n\n        # We read max 3 lines after the first difference\n        if diffLine is not None and solPostDiff > 3 and expPostDiff > 3:\n            truncatedAfter = truncatedAfter or (lastLine != '') and (lastLine != '\\ No newline at end of file\\n')\n            break\n\n    # Put a single line in the expected answer if it was empty\n    if len(expLines) == 0:\n        expLines = [\"\\n\"]\n\n    # Find difference in the diff line\n    relLine = diffLine-chunkLine\n    while relLine >= len(solLines):\n        solLines.append(\"\\n\")\n    solDLine = solLines[relLine]\n    while relLine >= len(expLines):\n        expLines.append(\"\\n\")\n    expDLine = expLines[relLine]\n    solCur = 0\n    expCur = 0\n    while True:\n        if solCur >= len(solDLine) or expCur >= len(expDLine):\n            break\n\n        if opt['ignoreSpaceChange']:\n            # We ignore consecutive whitespaces\n            # It's a line so the character before the first one is a newline\n            if solDLine[solCur] in whitespace:\n                if solCur == len(solDLine)-1:\n                    break\n                elif solCur == 0 or solDLine[solCur+1] in whitespace:\n                    solCur += 1\n                    continue\n            if expDLine[expCur] in whitespace:\n                if expCur == len(expDLine)-1:\n                    break\n                elif expCur == 0 or expDLine[expCur+1] in whitespace:\n                    expCur += 1\n                    continue\n\n        if solDLine[solCur] != expDLine[expCur]:\n            break\n        else:\n            solCur += 1\n            expCur += 1\n\n    # Start building report\n    result['msg'] = \"Answer mismatch at line %d, character %d\" % (diffLine, solCur+1)\n    result['solutionOutputLength'] = getsize(solPath)\n    result['diffRow'] = diffLine\n    result['diffCol'] = solCur+1\n\n    # Select lines to display\n    maxChars = opt['maxChars']\n    if len(solDLine) > maxChars or len(expDLine) > maxChars:\n        # We only display the differing line because it's already too long\n        if solCur < maxChars/2:\n            colStart = 0\n            colEnd = maxChars\n        elif len(solDLine) - solCur < maxChars/2:\n            colStart = len(solDLine)-maxChars\n            colEnd = max(len(solDLine), len(expDLine))\n        else:\n            colStart = solCur - maxChars/2\n            colEnd = solCur + maxChars/2\n        result['displayedSolutionOutput'] = utf8safe(solDLine[colStart:colEnd])\n        result['displayedExpectedOutput'] = utf8safe(expDLine[colStart:colEnd])\n        result['truncatedBefore'] = (diffLine > 1)\n        result['truncatedAfter'] = True\n        result['excerptRow'] = diffLine\n        result['excerptCol'] = colStart+1\n\n    else:\n        # We add lines before and/or after as long as we stay within maxChars\n        remChars = maxChars - max(len(solDLine), len(expDLine))\n        dispStartLine = relLine\n        dispSolEndLine = relLine\n        dispExpEndLine = relLine\n\n        # Add lines before from both solution and expected output\n        while dispStartLine > 0:\n            if len(solLines[dispStartLine-1]) > remChars:\n                break\n            else:\n                remChars -= len(solLines[dispStartLine-1])\n                dispStartLine -= 1\n\n        # Separately add lines from solution and expected output, as it's\n        # possible they don't have the same lines/number of lines\n        while dispSolEndLine < len(solLines)-1:\n            if len(solLines[dispSolEndLine+1]) > remChars:\n                break\n            else:\n                remChars -= len(solLines[dispSolEndLine+1])\n                dispSolEndLine += 1\n\n        while dispExpEndLine < len(expLines)-1:\n            if len(expLines[dispExpEndLine+1]) > remChars:\n                break\n            else:\n                remChars -= len(expLines[dispExpEndLine+1])\n                dispExpEndLine += 1\n\n        result['displayedSolutionOutput'] = utf8safe(''.join(solLines[dispStartLine:dispSolEndLine+1]))\n        result['displayedExpectedOutput'] = utf8safe(''.join(expLines[dispStartLine:dispExpEndLine+1]))\n        result['truncatedBefore'] = (dispStartLine + chunkLine > 1)\n        result['truncatedAfter'] = truncatedAfter\n        result['excerptRow'] = dispStartLine + chunkLine\n        result['excerptCol'] = 1\n\n    # Return a grade of 0 (answer mismatch) and the results info\n    return (0, result)\n\n\nif __name__ == '__main__':\n    if len(argv) != 4:\n        print \"Error: invalid number of arguments.\"\n        exit(1) # Exit code of 1 means a checker error\n\n    try:\n        grade, result = diff(argv[1], argv[3])\n    except:\n        print '0'\n        print 'Error during solution check, please contact an administrator.'\n        from traceback import print_exc\n        print_exc()\n        exit(1)\n\n    print grade\n    if grade != 100:\n        print dumps(result)\n", "name": "defaultChecker.py"}], "dependencies": [], "language": "python2"}, "compilationExecution": "@defaultToolCompParams"}, "defaultFilterTests-jvs": "@defaultFilterTests-javascool", "defaultFilterTests-pas": "@defaultFilterTests-pascal", "solutionContent": "", "defaultDependencies-shell": [], "defaultEvaluationSolutions": [{"compilationDescr": {"files": [{"path": "$TASK_PATH/tests/gen/runner.c", "name": "runner.c"}], "dependencies": [{"content": "@solutionContent", "path": "@solutionPath", "name": "solution.h"}], "language": "c"}, "id": "@solutionId", "compilationExecution": "@defaultSolutionCompParams"}], "defaultFilterTests-cpp": "@defaultFilterTests", "solutionExecId": "execution", "defaultDependencies-jvs": "@defaultDependencies-javascool"}